#!/usr/bin/perl
use strict;
use warnings;
use Mojolicious::Lite;
use Mojo::SQLite;
use Mojo::Date;
use Try::Tiny;
use Mojo::ByteStream 'b';

our $VERSION = '0.01';

$ENV{TZ} = 'UTC';

my $config = plugin 'Config' => {
    default => {
        minion_db    => 'sqlite:minion.db',
        registry_db  => 'sqlite:registry.db',
        delay        => 300,
        registration => 0,
    }
};

plugin Minion => { SQLite => $config->{minion_db} };

app->types->type( plain => 'text/plain;charset=UTF-8' );

helper find_new_urls => sub {
    my ( $self, $tweet ) = @_;
    while ( $tweet =~ m{\@<(\w+) (https?://[^>]+)>}g ) {
        my ( $nick, $url ) = ( $1, $2 );
        $self->add_user( $nick, $url );
    }
    return;
};

helper add_user => sub {
    my ( $self, $nick, $url ) = @_;
    $url = Mojo::URL->new($url);
    return if $url->scheme !~ /^https?/;

    ## If url scheme is https and there is already an url with the same http address
    ## just update the http address to https
    if ( $url->scheme eq 'https' ) {
        my $http_url = $url->clone->scheme('http');
        return
          if $self->sql->db->query( 'update users set url = ? where url is ?',
            $url, $http_url )->rows;
    }

    my $https_address = $url->clone->scheme('https');
    my $result        = $self->sql->db->query(
        q{
           insert into users ( nick, url )
             select ?,? where not exists
              (select 1 from users where url in ( ?, ? ))
     },
        $nick, $url, $url, $https_address
    );
    return if !$result->rows;

    my $id = $result->last_insert_id;
    $self->minion->enqueue( 'update', [$id], { delay => $config->{delay} } )
      if defined $id;
    return;
};

sub to_date {
    my ($date) = @_;
    return if !$date;
    $date =~ s/T(\d\d:\d\d)([Z+-])/T$1:00$2/;
    $date =~ s/([+-]\d\d)(\d\d)/$1:$2/;
    return Mojo::Date->new($date);
}

app->minion->add_task(
    update => sub {
        my ( $job, $id ) = @_;

        my $db  = $job->app->sql->db;
        my $log = $job->app->log;

        my $result =
          $db->query( 'select * from users where user_id is ?', $id )->hash;
	return if not defined $result;
	return if not $result->{active};
        my ( $nick, $url, $last_modified ) =
          @{$result}{qw( nick url last_modified )};

        $job->app->log->debug("Updating $url");

        $last_modified = Mojo::Date->new($last_modified) if $last_modified;

        my $params =
          $last_modified
          ? { 'If-Modified-Since' => $last_modified->to_string }
          : {};

        my $tx = $job->app->ua->get( $url, $params );

        try {
            $log->debug("Try $url");
            my $res = $tx->success;
            die $tx->error->{message} if !$res;

            $job->app->log->debug("Success $url");

            if ( $res->code == 301 || $res->code == 307 ) {
                $db->query( 'delete from users where url is ?', $url );
                $job->app->add_user( $nick, $res->headers->location );
                return;
            }
            elsif ( $res->code == 200 ) {
                my $now = Mojo::Date->new();
                for my $line ( split( "\n", b( $res->body )->decode ) ) {
                    next if $line =~ m/^\s*$/;
                    my ( $time, $tweet ) = split( "\t", $line, 2 );

                    $time = to_date($time);
		    $job->app->log->debug($tweet);
		    $job->app->log->debug($time);

                    die "Unparsable line $line\n"
                      if !defined $time || !defined $tweet;

                    next if $time->epoch > $now->epoch;

                    try {
                        $db->query(
                            'insert into tweets (user_id,timestamp,tweet)'
                              . ' values ((select user_id from users where url is ?),?,?)',
                            $url, $time->epoch, substr( $tweet, 0, 1024 )
                        );
                        $job->app->find_new_urls($tweet);
                    };

                }

                if ( $res->headers->last_modified ) {
                    my $date = Mojo::Date->new( $res->headers->last_modified );
                    if ( defined $date ) {
                        $db->query(
                            'update users set last_modified = ? where url is ?',
                            $date->epoch, $url
                        );
                    }
                }
            }

            $job->app->minion->enqueue( 'update', [$id],
                { delay => $config->{delay} } );

        }
        catch {
            $log->debug("Error: $_");
            $db->query(
                'update users set active = 0, last_error = ? where url is ?',
                $_, $url );

        };
        return;
    }
);

helper sql => sub {
    state $sql = do {
        my $sql = Mojo::SQLite->new( $config->{registry_db} );
        $sql->db->dbh->sqlite_create_function( 'to_rfc3339', 1,
            sub { Mojo::Date->new(shift)->to_datetime } );
        $sql->db->dbh->sqlite_create_function( 'to_mention', 2,
            sub { "@<$_[0] $_[1]>" } );
        $sql;
    };
};

helper offset => sub {
    my $c = shift;

    my $page = $c->param('page') || 1;
    $page = 1
      if $page <= 0 || $page !~ /^\d+$/;
    $c->stash( page => $page );

    my $offset = ( $page - 1 ) * 20;
    return $offset;
};

my $find_users_sql = <<EOF;
  SELECT url,to_rfc3339(timestamp) as time, nick FROM users
    WHERE url LIKE ? ORDER BY url LIMIT 20 OFFSET ?
EOF

my $find_tweets_base = <<EOF;
    from tweets join users on tweets.user_id == users.user_id
    where
          tweet like ?
      and case when ? then 1 else is_bot is 0 end
    order by tweets.timestamp desc limit 20 offset ?
EOF

my $find_tweets_1_0 = <<EOF;
  select to_mention(nick,url) as user,to_rfc3339(tweets.timestamp) as time, tweet
  $find_tweets_base
EOF

my $find_tweets_2_0 = <<EOF;
  select nick, url ,to_rfc3339(tweets.timestamp) as time, tweet
  $find_tweets_base
EOF

under '/api/:format/' => [ format => [ 'plain', 'json' ] ];

helper respond_to_api => sub {
    my ( $c, $sql, @bind_values ) = @_;
    return $c->respond_to(
        plain => sub {
            $c->render( text => $c->sql->db->query( $sql, @bind_values )
                  ->arrays->map( sub { join( "\t", @$_ ) } )->join("\n") );
        },
        json => sub {
            $c->render(
                json => $c->sql->db->query( $sql, @bind_values )->hashes );
        },
    );
};

helper format_tweet => sub {
	my ($c,$tweet) = @_;
	#$tweet = b($tweet)->xml_escape->to_string;
	$tweet =~ s{\@&lt;(\w+) ([^>]+)&gt;}{<a href="$2">\@$1</a>}g;
	return $tweet;
};

get '/users' => sub {
    my $c = shift;
    my $query = $c->param('q') || '%';
    return $c->respond_to_api( $find_users_sql, $query, $c->offset );
};

get '/tweets' => sub {
    my $c         = shift;
    my $query     = $c->param('q') || '%';
    my $show_bots = $c->param('show_bots') || 0;
    return $c->respond_to_api( $find_tweets_1_0, "%$query%", $show_bots,
        $c->offset );
};

get '/mentions' => sub {
    my $c         = shift;
    my $query     = $c->param('url');
    my $show_bots = $c->param('show_bots') || 0;
    return $c->render( status => 400, text => '`url` must be provided.' )
      if !$query;
    return $c->respond_to_api( $find_tweets_1_0, "%@<_% $query>",
        $show_bots, $c->offset );
};

get '/tags/#tag' => sub {
    my $c         = shift;
    my $query     = $c->param('tag');
    my $show_bots = $c->param('show_bots') || 0;
    return $c->render( status => 400, text => '`tag` must be provided.' )
      if !$query;
    return $c->respond_to_api( $find_tweets_1_0, "%#$query", $show_bots,
        $c->offset );
};

post '/users' => sub {
    my $c = shift;
    return $c->render( text => 'Registration closed.', status => 403 )
      if !$config->{registration};
    my ( $url, $nick ) = ( $c->param('url'), $c->param('nickname') );
    return $c->render( text => 'Oops.', status => 400 )
      if !$url || !$nick;
    $c->add_user( $nick, $url );
    return $c->render( text => 'Ok.', status => 200 );
};

under;

get '/' => sub {
    my $c = shift;
    my $show_bots = $c->param('show_bots') || 0;
    $c->stash( tweets =>
          $c->sql->db->query( $find_tweets_2_0, '%', $show_bots, $c->offset )
          ->hashes );
} => 'index';

app->start;

__DATA__

@@ index.html.ep

<!doctype html>
<html lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>twtxt roster</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.0.16/css/bulma.min.css">

    </head>
    <body>

<section class="hero">
  <div class="hero-content">
    <div class="container">
      <h1 class="title">
        TWTXT Roster
      </h1>
      <h2 class="subtitle">
         The decentralised, minimalist microblogging service for hackers
      </h2>
    </div>
  </div>
</section>

<div class="column"></div>

% for my $tweet ( $tweets->each ) {
<div class="columns">
<div class="column is-offset-4 is-4">
	<div class="box">
	  <article class="media">
	    <div class="media-content">
	      <div class="content">
		<p>
		  <a href="<%= $tweet->{url} %>"><strong><%= $tweet->{nick} %></strong></a> <small><%= $tweet->{time} %></small>
		  <br>
		  <%= format_tweet $tweet->{tweet} %>
		</p>
	      </div>
	    </div>
	  </article>
	</div>
</div>
</div>
% }

<div class="columns">

% if ( $page > 1 ) {
   <div class="column is-2 is-offset-4">
	<a href="<%= url_with->query([page => $page - 1 ]) %>" class="button">
          <i class="fa fa-arrow-left"></i>
          Newer tweets
        </a>
   </div>
% } else {
   <div class="column is-2 is-offset-4">
   </div>

% }

% if ( $tweets->each < 20 ) {
   <div class="column is-2 is-pulled-right">
   </div>
% } else {
   <div class="column is-2 is-pulled-right">
<a href="<%= url_with->query([page => $page + 1 ]) %>" class="button is-pulled-right">
    Older tweets
   <i class="fa fa-arrow-right"></i>
</a>
   </div>
% }

</div>

    </body>
</html>

__END__

=head1 NAME

twtxt_roster - api and search engine for twtxt

=head1 COPYRIGHT AND LICENSE

Copyright 2015 Mario Domgoergen C<< <mario@domgoergen.com> >>

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.
