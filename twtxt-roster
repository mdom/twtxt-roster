#!/usr/bin/perl
use strict;
use warnings;
use Mojolicious::Lite;
use Mojo::SQLite;
use Mojo::Date;
use Try::Tiny;
use Mojo::ByteStream 'b';

$ENV{TZ} = 'UTC';

my $config = plugin 'Config' => {
    default => {
        minion_db    => 'sqlite:minion.db',
        registry_db  => 'sqlite:registry.db',
        delay        => 300,
        registration => 0,
    }
};

plugin Minion => { SQLite => $config->{minion_db} };

helper find_new_urls => sub {
    my ( $self, $tweet ) = @_;
    while ( $tweet =~ m{\@<(?:(\w+) )?(https?://[^>]+)>}g ) {
        my ( $nick, $url ) = ( $1, $2 );
        $self->add_user( $nick, $url );
    }
    return;
};

helper add_user => sub {
    my ( $self, $nick, $url ) = @_;
    $url = Mojo::URL->new($url);
    return if $url->scheme !~ /^https?/;

    ## If url scheme is https and there is already an url with the same http address
    ## just update the http address to https
    if ( $url->scheme eq 'https' ) {
        my $http_url = $url->clone->scheme('http');
        return
          if $self->sql->db->query( 'update users set url = ? where url is ?',
            $url, $http_url )->rows;
    }

    my $https_address = $url->clone->scheme('https');
    my $result        = $self->sql->db->query(
        q{
	   insert into users ( nick, url )
       	       select ?,? where not exists
	          (select 1 from users where url in ( ?, ? ))
	 },
        $nick, $url, $url, $https_address
    );
    return if !$result->rows;

    my $id = $result->last_insert_id;
    $self->minion->enqueue( 'update', [$id], { delay => $config->{delay} } )
      if defined $id;
    return;
};

sub to_date {
    my ($date) = @_;
    return if !$date;
    $date =~ s/T(\d\d:\d\d)([Z+-])/T$1:00$2/;
    $date =~ s/([+-]\d\d)(\d\d)/$1:$2/;
    return Mojo::Date->new($date);
}

app->minion->add_task(
    update => sub {
        my ( $job, $id ) = @_;

        my $db  = $job->app->sql->db;
        my $log = $job->app->log;

        my $result =
          $db->query( 'select * from users where user_id is ?', $id )->hash;
        return if not defined $result;
        return if not $result->{active};
        my ( $nick, $url, $last_modified ) =
          @{$result}{qw( nick url last_modified )};

        $job->app->log->debug("Updating $url");

        $log->debug("Update for unknown user $url. Skipping")
          if !$result;

        $last_modified = Mojo::Date->new($last_modified)->to_string
          if $last_modified;

        my $params =
          $last_modified
          ? { 'If-Modified-Since' => $last_modified }
          : {};

        my $tx = $job->app->ua->get( $url, $params );

        try {
            $log->debug("Try $url");
            my $res = $tx->success;
            die $tx->error->{message} if !$res;

            $job->app->log->debug("Success $url");

            if ( $res->code == 301 || $res->code == 307 ) {
                $db->query( 'delete from users where url is ?', $url );
                $job->app->add_user( $nick, $res->headers->location );
                return;
            }
            elsif ( $res->code == 200 ) {
                my $now = Mojo::Date->new();
                for my $line ( split( "\n", b( $res->body )->decode ) ) {
                    next if $line =~ m/^\s*$/;
                    my ( $time, $tweet ) = split( "\t", $line, 2 );

                    $time = to_date($time);

                    die "Unparsable line $line\n"
                      if !defined $time || !defined $tweet;

                    next if $time->epoch > $now->epoch;

                    try {
                        $db->query(
                            'insert into tweets (user_id,timestamp,tweet)'
                              . ' values ((select user_id from users where url is ?),?,?)',
                            $url, $time->epoch, $tweet );
                        $job->app->find_new_urls($tweet);
                    };

                }

                if ( $res->headers->last_modified ) {
                    my $date = Mojo::Date->new( $res->headers->last_modified );
                    if ( defined $date ) {
                        $db->query(
                            'update users set last_modified = ? where url is ?',
                            $date->epoch, $url
                        );
                    }
                }
            }

            $job->app->minion->enqueue( 'update', [$id], { delay => 60 } );

        }
        catch {
            $log->debug("Error: $_");
            $db->query(
                'update users set active = 0, last_error = ? where url is ?',
                $_, $url );

        };
        return;
    }
);

my $sql;
helper sql => sub {
    if ( !$sql ) {
        $sql = Mojo::SQLite->new( $config->{registry_db} );
        $sql->db->dbh->sqlite_create_function( 'to_rfc3339', 1,
            sub { Mojo::Date->new(shift)->to_datetime } );
        $sql->db->dbh->sqlite_create_function( 'to_mention', 2,
            sub { "@<$_[0] $_[1]>" } );
    }
    return $sql;
};

helper to_text => sub {
    my ( $c, $sql, @bind_values ) = @_;
    $c->sql->db->query( $sql, @bind_values )
      ->arrays->map( sub { join( "\t", @$_ ) } )->join("\n");
};

helper offset => sub {
    my $c      = shift;
    my $page   = $c->param('page');
    my $offset = $page && $page > 0 ? ($page - 1) * 20 : 0;
    return $offset;
};

under '/api/:format/' => { format => ['plain'] };

get '/users' => sub {
    my $c = shift;
    my $query = $c->param('q') || '%';
    return $c->render(
        text => $c->to_text(
            'SELECT url,to_rfc3339(timestamp),nick FROM users WHERE url LIKE ? ORDER BY url LIMIT 20 OFFSET ?',
            $query, $c->offset
        )
    );
};

my $find_tweets_sql = <<EOF;
  select to_mention(nick,url),to_rfc3339(tweets.timestamp),tweet
    from tweets join users on tweets.user_id == users.user_id
    where tweet like ?
    order by tweets.timestamp desc limit 20 offset ?
EOF

get '/tweets' => sub {
    my $c      = shift;
    my $query  = $c->param('q') || '%';
    my @data   = @{ [] };
    return $c->render(
        text => $c->to_text( $find_tweets_sql, "%$query%", $c->offset ) );
};

get '/mentions' => sub {
    my $c      = shift;
    my $query  = $c->param('url');
    return $c->render( status => 400, text => '`url` must be provided.' )
      if !$query;
    return $c->render(
        text => $c->to_text( $find_tweets_sql, "%@<_% $query>", $c->offset ) );
};

get '/tags/#tag' => sub {
    my $c      = shift;
    my $query  = $c->param('tag');
    return $c->render( status => 400, text => '`tag` must be provided.' )
      if !$query;
    return $c->render(
        text => $c->to_text( $find_tweets_sql, "%#$query", $c->offset ) );
};

post '/users' => sub {
    my $c = shift;
    return $c->render( text => 'Registration closed.', status => 403 )
      if !$config->{registration};
    my ( $url, $nick ) = ( $c->param('url'), $c->param('nickname') );
    return $c->render( text => 'Oops.', status => 400 )
      if !$url || !$nick;
    $c->add_user( $nick, $url );
    return $c->render( text => 'Ok.', status => 200 );
};

app->start;
